1、纽约地图非常大，节点多，但是十分稀疏，很多蚂蚁可能无法找到从起点到达终点的通路。

2、蚂蚁的初始化出发点都在起点，蚂蚁的初始化基本上不具备随机性。

一些可能的改进方式：
1、将启发示因子由  当前节点到待选节点的距离的倒数   改进为   待选节点到终点的距离的倒数
因为我们所追求的不完全是总体上距离最小，而是尽可能地向寻找到目标，所以需要更多的向目标靠近


2、建立网络社团结构，从而实现对大规模网络的分层化设计。
主要方法为找出区域枢纽点 可参考孙兵的那一篇学位论文

1.14
枢纽点就算找好了，但是如何确定哪些枢纽点之间应该存在连边呢？

改进蚁群算法的启示式因子的幂，因为一开始都不一定能够找到路径，不妨更加贪心一些，减少一些随机性。
随机性的好处在于能够更好地获得全局最优，但是在工程上，能够找到一条路径就已经是比较好的结果了。


1.17
完成了多因素多目标优化的加权统一
建立了多个因素的图网络，然后进行合并，由用户选择权重向量

1.18
使用networkx可以很快地求出两点之间的最短距离。
可以快速实现对图的预处理。找出区域枢纽点之间的最短路，然后进行储存，等需要时可以直接进行查询。


对于如何建立区域枢纽点之间的连边，
初步想法是，对于某一区域枢纽点，选择空间矩离它最近的20个枢纽点，然后分别求其与这20个区域枢纽点之间的最短路径，视为该枢纽点与周围枢纽点形成一条连边，权重即为最短路径的距离。
如果某一条最短路径途径了某一枢纽点，则不把该最短路径作为连边。


在区域枢纽点和连边建立好之后，即可以认为是高一级图网络建好了。
之后就可以直接进行子图划分。
子图划分的想法是，直接对非区域枢纽点，按照其空间距离哪个区域枢纽点最近，就将其划分到该枢纽点的区域内。

整个分层优化的算法流程即为，
1、先是查询起点和终点分别属于哪一个枢纽点的范围内。
2、分别使用蚁群算法，找到起点到其枢纽点a的最短路径，终点到其枢纽点b的最短路径。
3、在高一级图网络中，使用蚁群算法，找到枢纽点a到枢纽点b的最短路径。
4、再细化低一级图网络的路径查询。
5、再考虑引入多目标优化后的处理结果。


1.19
完成对区域枢纽点子图的建立，枢纽点子间最短路径的存储。
对其它非枢纽点，进行了子图划分。找到其对应的最近枢纽点。

1.20
gap一天

1.21
将蚁群算法原本的代码，更改了一下数据初始化格式等等，大大缩短搜索时间，减小内存占用。

蚁群算法为什么会慢那么多，
因为其存在概率接受，所以常常会把路径引导入那些并不是很优的路径中去，可能还会走进死胡同。
而且由于每一只蚂蚁的出发点都是起点，而不是随机分散在图中的其它节点上，所以并行运算的优势无法体现出来。
相当于每一只蚂蚁一直在重复前面蚂蚁的工作。除非前面的蚂蚁已经找到路径，否则依然是碰运气。
路径短一点的话还好，能够在较短的时间内碰出来。但是路径一旦很长，就十分困难了。第一只找到路径的蚂蚁总是迟迟无法出现。

1.22
完成分层算法下，多次蚁群算法实现近似最短路径的寻优。

1.25
在windows以及linux下配置git，然后将代码clone到虚拟机的master上，使用ipython的方式进行调试

1.26
学习和研究spark在本地模式下的运行原理。
学习如何使用RDD的方式进行分布式程序编写。

广播变量为什么无法设邻接表为广播变量啊！

1.27
好像是类对象必须满足可Serializable， 可序列化？

应该需要满足一定的条件，才可以序列化。

在python中使用networkx这个类所定义的图，可以转化为广播变量
可以使用这个类对蚁群算法的代码进行改写。

ant类好像转化为RDD时也会出问题，应该也是不可序列化的原因。
到底要怎么创建类才可以可序列化呢？

1.30
使用nx对蚁群算法进行了改写

2.14
成功实现将ant类转化为RDD。具体的方法，不过是将ant类中所用到的图对象（如distance_nx_graph，以及pheromone_nx_graph），作为形参传入。

但是还是无法实现map的分工，具体原因未知，可以尝试一下将自定义类分文件封装。
因为尝试了对更标准的类包所定义的对象（networkx）进行map分工，发现是可以的。
但是对自定义的类进行map分工却报错了。

2.15
尝试一下将自定义类分文件封装，发现真的可以诶
倒是没有报错了，但是就是一直跑不完一次迭代。

先尝试将Ant类分文件再import进来之后，非map方式运行，是否会报错。